# Sod問題（1D衝撃波管問題）

## 1. 概要
Sod問題は、左と右で状態が異なる気体を1本の管に入れておき、中央の隔壁を外した瞬間に生じる波の伝播（**衝撃波・接触不連続・膨張波**）を、**1次元Euler方程式**で計算する検証問題である。

---

## 2. 初期条件（Sod）
- 左状態：$\rho_L=1.0,\; u_L=0.0,\; p_L=1.0$
- 右状態：$\rho_R=0.125,\; u_R=0.0,\; p_R=0.1$
- 比熱比：$\gamma=1.4$

---

## 3. 支配方程式（保存形Euler方程式）
1次元Euler方程式は保存形で
$$
\frac{\partial U}{\partial t}+\frac{\partial F(U)}{\partial x}=0
$$
ここで「保存量」と「流束」は次の通り。

### 3.1 保存量 $U$
1D圧縮性流れの保存則は3つ（質量・運動量・エネルギー）なので
$$
U=
\begin{pmatrix}
\rho\\
\rho u\\
E
\end{pmatrix}
$$
- $\rho$：密度
- $\rho u$：運動量密度
- $E$：全エネルギー密度（内部＋運動）

（コードでは `Cons { r, ru, E }`）

### 3.2 物理流束 $F(U)$
粘性なし（摩擦なし）なので、輸送は「対流」と「圧力の押し」で決まり
$$
F(U)=
\begin{pmatrix}
\rho u\\
\rho u^2 + p\\
u(E+p)
\end{pmatrix}
$$
- 1行目：質量が右へ運ばれる（$\rho u$）
- 2行目：運動量の対流（$\rho u^2$）＋圧力による押し（$p$）
- 3行目：エネルギーの対流（$uE$）＋圧力仕事（$up$）

---

## 4. 箱モデル（有限体積法）と「数値流束」が必要な理由
計算領域をセル（箱）に分割し、セル $i$ は「中身」としてセル平均の保存量 $U_i$ を持つ。

セルの中身は、**左右の界面からどれだけ出入りしたか**で変化する。  
つまり、

> **中身の増減 =（左から入る）−（右へ出る）**

この考えを式にすると、セル $i$ の更新は
$$
\frac{dU_i}{dt} = -\frac{\hat F_{i+1/2}-\hat F_{i-1/2}}{\Delta x}
$$
となる。

ここで重要なのは、使うべき流束は **セル中心の $F(U_i)$ ではなく**、  
**界面を実際に通過する流れ（数値流束）$\hat F_{i+1/2}$** である点。

特にSod問題では左と右で状態が違い、界面では
- 左側：$W_L$（セル $i$ の状態）
- 右側：$W_R$（セル $i+1$ の状態）
が食い違うため、界面ごとに「通過流束」を計算する必要がある。

（コードの形：`rhs[i] = -(F[i] - F[i-1]) / dx;`）

---

## 5. 界面の左右状態（今回はMUSCLなし＝空間1次）
MUSCLやlimiterを使わない（空間1次）ので、界面 $i+1/2$ の左右状態は単純に
- $W_L = W_i$
- $W_R = W_{i+1}$
（セル中心値そのまま）
とする。

このため不連続はにじみやすいが、実装が単純で安定に動かしやすい。

---

## 6. 数値流束の作り方：Roe-FDS（超やさしく）

界面 $i+1/2$ では、左セルと右セルで状態が違うので
- 左の状態 $W_L$
- 右の状態 $W_R$
から「界面を通る流れ（数値流束）$\hat F$」を決める必要がある。

Sod問題では初期に段差があるため、ここが計算の一番大事な部分になる。

---

### 6.1 まず「平均」を考える（でもそれだけだと危ない）
左の物理流束を $F_L=F(W_L)$、右を $F_R=F(W_R)$ とすると、
「とりあえず真ん中は平均っぽいだろう」として

$$
\frac{F_L+F_R}{2}
$$

を界面流束にしたくなる。

しかし、衝撃波のような急な段差があると **平均だけの方法は振動（ギザギザ）を出しやすい**。
（中心差分は“風上”を見ていないため、不連続に弱い。）

---

### 6.2 Roe-FDSの発想：「平均 − ブレーキ（散逸）」
そこでRoe-FDSは、平均流束に **ブレーキ（散逸）**を加えて安定化する。

$$
\hat F
=
\frac{F_L+F_R}{2}
-\frac{1}{2}\sum_{k=1}^{3} |\lambda_k|\alpha_k r_k
$$

この式の読み方はシンプルで、

- $\dfrac{F_L+F_R}{2}$：**平均で作った“素の流れ”**
- $-\dfrac12(\cdots)$：**段差があるときだけ働く“ブレーキ”**（振動防止）

ポイント：もし左右が同じ状態なら $W_L=W_R$ なので段差はゼロになり、
$\alpha_k \approx 0$ となってブレーキ項は消える（＝平均と同じになる）。

---

### 6.3 「ブレーキ項」の中身は何をしている？
ブレーキ項

$$
\sum_{k=1}^{3} |\lambda_k|\alpha_k r_k
$$

は、**左右の段差（不連続）を “3種類の伝わり方” に分けてから、必要なだけ散逸を入れる**
という意味。

- $k=1,2,3$ ：1D Euler が持つ **3つのモード（伝わり方）**  
  （左向き音波・接触波・右向き音波）
- $|\lambda_k|$：そのモードの **伝わる速さ**（速いほど散逸も強めに必要）
- $\alpha_k$：そのモードが **どれくらい出るか（段差の分解係数）**
- $r_k$：そのモードの **段差の形（ベクトル）**

つまり「段差を3種類に分けて、速さ×強さに応じてブレーキを配る」式になっている。

---

### 6.4 もっと短く言うと（1行要約）
Roe-FDSは

> **左右の平均流束に、波の速さに応じた“風上（upwind）散逸”を足して安定化する方法**

である。

---

### 6.5 コードでは実際に何を計算している？（手順）
Roe-FDSで界面流束 $\hat F_{i+1/2}$ を作る処理は、だいたい次の手順になる：

1. 左右の状態 $W_L, W_R$ を用意（今回は空間1次なので $W_L=W_i,\;W_R=W_{i+1}$）
2. 左右の物理流束 $F_L, F_R$ を計算
3. Roe平均（代表状態）$\tilde u,\tilde H,\tilde a$ を計算
4. 3つの波の速さ（固有値）  
   $\lambda_1=\tilde u-\tilde a,\;\lambda_2=\tilde u,\;\lambda_3=\tilde u+\tilde a$
5. 左右の段差を3モードに分解して係数 $\alpha_1,\alpha_2,\alpha_3$ を求める
6. 散逸（ブレーキ）$\sum |\lambda_k|\alpha_k r_k$ を作る
7. 最後に  
   $\hat F=\dfrac{F_L+F_R}{2}-\dfrac12(\text{ブレーキ})$
---

### 6.6. Roe平均（$\tilde u,\tilde H,\tilde a$）の役割
Roe-FDSでは「界面の代表状態」を作り、その状態で波の速さを決める。

全エンタルピー：
$$
H=\frac{E+p}{\rho}
$$
Roe平均：
$$
\tilde u
=
\frac{\sqrt{\rho_L}u_L+\sqrt{\rho_R}u_R}{\sqrt{\rho_L}+\sqrt{\rho_R}},\quad
\tilde H
=
\frac{\sqrt{\rho_L}H_L+\sqrt{\rho_R}H_R}{\sqrt{\rho_L}+\sqrt{\rho_R}}
$$
音速：
$$
\tilde a^2
=
(\gamma-1)\left(\tilde H-\frac{1}{2}\tilde u^2\right)
$$

この $\tilde u,\tilde a$ を使って $\lambda_k$ が決まるため、「散逸をどれだけ入れるか」が決まる。

---

### 6.7 実務上の注意（なぜ entropy fix や Rusanov がある？）
Roe法は鋭いが、膨張波付近で不自然な解が出たり、負圧などで壊れることがある。

そのため実装では
- **entropy fix**：$|\lambda|$ を小さい領域で滑らかにして変な解を抑える
- **Rusanovへの退避**：状態が非物理（負密度/負圧）なら拡散強めの流束に切替

といった安全策を入れることが多い。



---
## 7. 境界条件：ゴーストセル（流出境界）

### 7.1 なぜゴーストセルが必要か
有限体積法では界面流束 $\hat F_{i+1/2}$ を計算するために、端の界面でも
「左の状態」「右の状態」が必要になる。  
しかし計算領域の外側にはセルが無いので、外側にダミーセル（ゴーストセル）を置いて補う。

### 7.2 transmissive（ゼロ勾配）境界の意味
流出境界（transmissive）は「境界の外側も、境界内側と同じ状態」とみなす境界。  
つまり「外側への勾配が0（ゼロ勾配）」になるようにコピーする。

ゴーストセルを左右2個ずつ持つ場合（$ng=2$）の典型：

- 左端：$U[0]=U[2],\; U[1]=U[2]$
- 右端：$U[n\_tot-1]=U[n\_tot-3],\; U[n\_tot-2]=U[n\_tot-3]$

これにより端で人工的な反射が出にくくなる。

## 8. 右辺 $L(U)$（rhs）の作り方：結局「何を計算しているのか」

ここが一番大事です。  
**rhs は「次の瞬間にセルの中身がどれだけ増減するか（時間微分）」を表す配列**です。

---

### 8.1 まず結論：rhs は「セル内の増減率（収支）」そのもの

有限体積法ではセル $i$ の中身 $U_i$ の変化は、

- 左の壁（界面 $i-1/2$）から **入ってくる量**
- 右の壁（界面 $i+1/2$）から **出ていく量**

の差で決まります。

式で書くと：

$$
\frac{dU_i}{dt}
=
-\frac{\hat F_{i+1/2}-\hat F_{i-1/2}}{\Delta x}
$$

ここで

- $\hat F_{i-1/2}$：左の界面を通る流束
- $\hat F_{i+1/2}$：右の界面を通る流束

です。

**つまり**

> 右へ出る量（右界面）− 左から入る量（左界面）  
> を取って、セル幅 $\Delta x$ で割ったものが「増減率」

になります。

この「増減率」をコードでは **rhs[i]** に入れます：

$$
rhs[i] \equiv \frac{dU_i}{dt} = L(U)_i
$$

---

### 8.2 「なぜ流束差分なのか」を箱の絵でイメージする

セル $i$ を幅 $\Delta x$ の箱だと思うと、

- 右壁から流束 $\hat F_{i+1/2}$ が出ていく（右向き正）
- 左壁から流束 $\hat F_{i-1/2}$ が入ってくる（右向き正）

なので、**箱の中身は**

$$
\text{増える} \;\; \Leftrightarrow \;\; \text{入る} > \text{出る}
$$

を満たすとき増えます。

収支で書くと

$$
\text{中身の増減} = (\text{左から入る}) - (\text{右へ出る})
$$

これを「右向き流束」の符号で統一すると

$$
\text{中身の増減} = -(\hat F_{i+1/2}-\hat F_{i-1/2})
$$

となり、さらにセル幅で割って「単位体積あたり」に直すと 8.1 の式になります。

---

### 8.3 実装では「2段階」だけ（ここを押さえる）

rhs を作る処理は必ず次の2段階です。

#### (A) まず界面流束 $F[i]=\hat F_{i+1/2}$ を全部作る
界面はセルの間にあります。  
例えばセル $i$ と $i+1$ の境目が界面 $i+1/2$ です。

実装では「界面番号」を整数で持つことが多く、例えば

- `F[i]` を「界面 $i+1/2$ の流束」と決める

というルールにします。

すると界面流束は

$$
F[i] \equiv \hat F_{i+1/2}
$$

になります。

#### (B) 次に流束差分で rhs を作る
すると更新式は

$$
rhs[i] = -\frac{F[i] - F[i-1]}{\Delta x}
$$

となります。

---

### 8.4 「空間1次（MUSCLなし）」なら界面の左右状態はこれだけ

界面 $i+1/2$ の流束 $\hat F_{i+1/2}$ を計算するには、
界面の左右の状態が必要です。

空間1次（MUSCLなし）なら超単純で

- 左状態：$W_L = W_i$
- 右状態：$W_R = W_{i+1}$

（セル中心値をそのまま使う）

よって

$$
\hat F_{i+1/2} = \mathrm{RoeFlux}(W_i,\, W_{i+1})
$$

で界面流束が決まります。

---

### 8.5 具体的にコードで何が起きているか（擬似コード）

以下は「compute_rhs がやっていること」を最小の形で書いたものです。

```c
// 1) セル中心の保存量U[i] -> 物理量W[i]に変換
for i:
  W[i] = cons_to_prim(U[i]);

// 2) 界面ごとに数値流束F[i] = F_{i+1/2}を作る
for i = 1 .. n_tot-3:
  F[i] = RoeFlux(W[i], W[i+1]);

// 3) セルごとに rhs[i] = -(F[i]-F[i-1])/dx を計算
for i = 2 .. n_tot-3:
  rhs[i] = -(F[i] - F[i-1]) / dx;
```

---
## 9. 時間刻み：CFL条件で $\Delta t$ を決める（詳説）

### 9.1 なぜCFLが必要か（「情報が飛び越える」と何がまずい？）
このSod問題のコードは **陽解法**（explicit）です。  
陽解法は「今ある情報」だけを使って次の時刻の値を作るので、1ステップで **波（情報）が遠くまで進みすぎる** と、計算が破綻しやすくなります。

有限体積法の更新式（1成分だけ見ても同じ形）は

$$
U_i^{n+1}
=
U_i^{n}
-
\frac{\Delta t}{\Delta x}\left(\hat F_{i+1/2}^n-\hat F_{i-1/2}^n\right)
$$

ここで重要なのは係数

$$
\frac{\Delta t}{\Delta x}
$$

が大きすぎると、セル $i$ の更新が **「隣の情報」どころか「もっと遠いセルの影響」を無理やり取り込む** ような状態になり、
- 数値振動（ギザギザ）
- 負圧・負密度（非物理）
- 発散（NaN）

が起きやすくなります。

---

### 9.2 「情報（波）」の速さは何で決まる？（Eulerの波の速度）
1D Euler方程式の「波」は3種類ありました（音波2つ＋接触波1つ）。  
このうち **最も速いのは音波**で、流体速度 $u$ に対して音速 $a$ で伝わります。

したがって、波の伝播速度は代表的に

- 右向き最大：$u+a$
- 左向き最大：$u-a$

で、絶対値の最大は

$$
|u|+a
$$

になります。

音速 $a$ は理想気体の関係から

$$
a=\sqrt{\gamma \frac{p}{\rho}}
$$

です（$\gamma$ は比熱比）。

---

### 9.3 CFL条件の意味（「1ステップで何セル進んでいいか」）
「1ステップで波がどれくらい進むか」は

$$
\text{移動距離} \approx (|u|+a)\Delta t
$$

セル幅は $\Delta x$ なので、**波が1ステップでセル幅を超えて飛び越えない**ようにしたい：

$$
(|u|+a)\Delta t \lesssim \Delta x
$$

これを $\Delta t$ について解くと

$$
\Delta t \lesssim \frac{\Delta x}{|u|+a}
$$

ただし「ギリギリ」だと不安定になりやすいので、安全率として **CFL数**（$0<\mathrm{CFL}<1$）を掛けます：

$$
\Delta t
=
\mathrm{CFL}\frac{\Delta x}{|u|+a}
$$

---

### 9.4 なぜ「最大値（max）」を取るのか
計算領域のどこか1セルでも波が速いところがあると、そこが破綻の原因になります。  
だから全セルで

$$
s_i = |u_i| + a_i
$$

を計算して、最も厳しい（最大の）速度

$$
s_{\max}=\max_i s_i
$$

を使って時間刻みを決めます：

$$
\Delta t
=
\mathrm{CFL}\frac{\Delta x}{s_{\max}}
$$

---

### 9.5 Sod問題だと「どれくらいの $\Delta t$ になりそう？」
初期状態は $u=0$ なので、最初は $s_{\max}\approx a$ で決まります。

左側：
$$
a_L=\sqrt{\gamma\frac{p_L}{\rho_L}}=\sqrt{1.4\cdot\frac{1.0}{1.0}}=\sqrt{1.4}\approx 1.183
$$

右側：
$$
a_R=\sqrt{1.4\cdot\frac{0.1}{0.125}}=\sqrt{1.12}\approx 1.058
$$

なので最初は $s_{\max}\approx 1.183$。

例えば $NX=400$、区間長 $1$ なら
$$
\Delta x=\frac{1}{400}=0.0025
$$

CFL=0.5 なら

$$
\Delta t \approx 0.5\cdot\frac{0.0025}{1.183}\approx 0.00106
$$

（実際は時間が進むと $u$ も出てくるので $s_{\max}$ が変化し、$\Delta t$ も変わります。）

---

### 9.6 実装では何をする？（やることは3行）
C言語の流れは次の通りです：

1. 各セルで $(\rho,u,p)$ を作る（`cons_to_prim`）
2. $a=\sqrt{\gamma p/\rho}$ を計算
3. $s=|u|+a$ の最大値 `smax` を取る
4. $\Delta t = \mathrm{CFL}\cdot \Delta x / smax$

擬似コード：

```c
double smax = 1e-14;
for (i = i_start; i <= i_end; i++) {
  Prim W = cons_to_prim(U[i]);
  double a = sqrt(GAMMA * W.p / W.r);
  smax = max(smax, fabs(W.u) + a);
}
double dt = CFL * dx / smax;
```



## 10. 時間積分：2段 Runge–Kutta（TVD RK2）で時間発展させる（超詳説）

ここでは「rhs を作れた（空間離散できた）」あとに、**時間方向にどうやって $U$ を進めるか**を説明します。  
結論から言うと、TVD RK2 は

- **1回目：とりあえず前進（予測）**
- **2回目：もう一回 rhs を取り直して、平均して修正（安定＆2次精度）**

をする方法です。

---

### 10.1 空間離散後になぜ ODE になるのか（$dU/dt=L(U)$ の意味）
もともとの PDE（偏微分方程式）は

$$
\frac{\partial U}{\partial t}+\frac{\partial F(U)}{\partial x}=0
$$

有限体積法で空間だけ離散すると、セル $i$ ごとに

$$
\frac{dU_i}{dt}
=
-\frac{\hat F_{i+1/2}-\hat F_{i-1/2}}{\Delta x}
$$

となります。

ここで右辺を

$$
L(U)_i \equiv -\frac{\hat F_{i+1/2}-\hat F_{i-1/2}}{\Delta x}
$$

と定義すると、

- $U$（全セルの保存量配列）を入れると
- $L(U)$（全セルの時間微分 $dU/dt$）が返ってくる

という形になり、全体として

$$
\frac{dU}{dt}=L(U)
$$

という **巨大な常微分方程式（ODE）** になります。  
（未知数は「全セル×3成分」ぶんあるので巨大ですが、形は ODE です。）

---

### 10.2 いちばん単純な時間積分：前進Euler（なぜダメになりやすい？）
まず比較のため、最も単純な方法は

$$
U^{n+1}=U^n+\Delta t\,L(U^n)
$$

です（前進Euler）。

これは実装が簡単ですが、

- 時間精度は **1次**
- 衝撃波問題では **振動が出やすい／安定性が弱い**

という欠点があります。

そこで「2回 rhs を評価して、より良い $U^{n+1}$ を作る」のが RK2 です。

---

### 10.3 Shu–Osher 形式（TVD RK2）の式を“処理手順”として読む
TVD RK2（Shu–Osher形式）は次の2ステージです。

#### 1段目（予測：Eulerを1回やる）
$$
U^{(1)} = U^n + \Delta t\,L(U^n)
$$

- 今の状態 $U^n$ で rhs（＝$L(U^n)$）を作って
- Eulerで一歩進めた仮の状態 $U^{(1)}$ を作ります。
- ここまでなら「前進Eulerと同じ」です。

#### 2段目（修正：もう一度 rhs を取り直して平均する）
$$
U^{n+1}
=
\frac12 U^n
+\frac12\left(U^{(1)}+\Delta t\,L(U^{(1)})\right)
$$

これは見た目が複雑ですが、意味はこうです：

1. まず $U^{(1)}$ を **もう一回 Euler で進める**：
   $$
   \tilde U = U^{(1)}+\Delta t\,L(U^{(1)})
   $$
2. その結果 $\tilde U$ と、元の $U^n$ を **1:1で平均**して次の時刻にする：
   $$
   U^{n+1}=\frac12 U^n + \frac12 \tilde U
   $$

つまり「Eulerを2回やって、その情報を混ぜて賢くする」方式です。

---

### 10.4 直感（なぜ2次精度になる？）
イメージとしては「傾き（rhs）を2点で見る」からです。

- Euler は「今の傾き $L(U^n)$ だけ」で次を決める  
  → 傾きの見積もりが雑（1次）
- RK2 は
  - まず仮に進めて $U^{(1)}$ を作り
  - その点での傾き $L(U^{(1)})$ も見る  
  → 時間方向のカーブをより良く追える（2次）

時間方向のテイラー展開に整合するように係数（$1/2$ とか）が選ばれている、と考えると良いです。

---

### 10.5 「TVD」って何がうれしい？（衝撃波で効くポイント）
TVD = Total Variation Diminishing（全変動が増えない）  
ざっくり言うと

> **ギザギザ（数値振動）が増えにくいように設計されたRK2**

です。

衝撃波や接触不連続は、どうしても「急な段差」が出ます。  
ここで普通の高次法を使うと、段差の前後にオーバーシュート（振動）が出やすいです。

Shu–Osher形式は「（空間の離散がTVDなら）時間積分でもTVDを保ちやすい」形になっているので、衝撃波問題でよく使われます。

※ただし注意：
- 空間1次（今のあなたの設定）はもともと拡散が強いので振動は出にくい
- MUSCLなど高次にしたときに、TVD性がより効いてきます

---

### 10.6 実装で「実際に何をするか」（手順を完全に分解）
TVD RK2 をコードに落とすと、やることは次の通りです。

#### (0) 準備：ゴーストセル更新
毎回 rhs 計算の前に境界条件を入れます（ゴーストセルコピーなど）。

#### (1) ステージ1：$U^{(1)} = U^n + \Delta t L(U^n)$
1. `apply_bc(U)`
2. `compute_rhs(U, rhs)`
3. `U1 = U + dt*rhs`

#### (2) ステージ2：$U^{n+1} = 0.5 U^n + 0.5 (U1 + dt L(U1))$
1. `apply_bc(U1)`
2. `compute_rhs(U1, rhs)`
3. `tmp = U1 + dt*rhs`
4. `U = 0.5*U + 0.5*tmp`

---

### 10.7 典型的なCコード（そのまま写せる形）
保存量が `Cons {r, ru, E}` の場合の例です。

```c
// --- stage 1 ---
apply_bc(U, n_tot);
compute_rhs(U, rhs, dx, n_tot);
for (int i = 0; i < n_tot; i++) {
    U1[i].r  = U[i].r  + dt * rhs[i].r;
    U1[i].ru = U[i].ru + dt * rhs[i].ru;
    U1[i].E  = U[i].E  + dt * rhs[i].E;
}

// --- stage 2 ---
apply_bc(U1, n_tot);
compute_rhs(U1, rhs, dx, n_tot);
for (int i = 0; i < n_tot; i++) {
    double r  = U1[i].r  + dt * rhs[i].r;
    double ru = U1[i].ru + dt * rhs[i].ru;
    double E  = U1[i].E  + dt * rhs[i].E;

    U[i].r  = 0.5 * U[i].r  + 0.5 * r;
    U[i].ru = 0.5 * U[i].ru + 0.5 * ru;
    U[i].E  = 0.5 * U[i].E  + 0.5 * E;
}
